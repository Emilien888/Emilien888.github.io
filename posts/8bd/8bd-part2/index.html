<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>8bit Duels Devlog Part 2 | ThousandthStar's blog</title><meta name=keywords content><meta name=description content="Hello readers! This is my progress for week 2 of coding my multiplayer game with Rust and Bevy. This post is a bit late, and should’ve been out yesterday, but I wasn&rsquo;t able to make it in time. Anyways, here is my progress this week. As a reminder, this is only a side project, and I don&rsquo;t work on it for extended periods of time, so progress is slow.
In this post, we will cover three things:"><meta name=author content><link rel=canonical href=https://thousandthstar.github.io/posts/8bd/8bd-part2/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://thousandthstar.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://thousandthstar.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://thousandthstar.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://thousandthstar.github.io/apple-touch-icon.png><link rel=mask-icon href=https://thousandthstar.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZP55MZZT7E"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZP55MZZT7E",{anonymize_ip:!1})}</script><meta property="og:title" content="8bit Duels Devlog Part 2"><meta property="og:description" content="Hello readers! This is my progress for week 2 of coding my multiplayer game with Rust and Bevy. This post is a bit late, and should’ve been out yesterday, but I wasn&rsquo;t able to make it in time. Anyways, here is my progress this week. As a reminder, this is only a side project, and I don&rsquo;t work on it for extended periods of time, so progress is slow.
In this post, we will cover three things:"><meta property="og:type" content="article"><meta property="og:url" content="https://thousandthstar.github.io/posts/8bd/8bd-part2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-02T18:12:30-05:00"><meta property="article:modified_time" content="2022-12-02T18:12:30-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="8bit Duels Devlog Part 2"><meta name=twitter:description content="Hello readers! This is my progress for week 2 of coding my multiplayer game with Rust and Bevy. This post is a bit late, and should’ve been out yesterday, but I wasn&rsquo;t able to make it in time. Anyways, here is my progress this week. As a reminder, this is only a side project, and I don&rsquo;t work on it for extended periods of time, so progress is slow.
In this post, we will cover three things:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://thousandthstar.github.io/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://thousandthstar.github.io/posts/8bd/"},{"@type":"ListItem","position":3,"name":"8bit Duels Devlog Part 2","item":"https://thousandthstar.github.io/posts/8bd/8bd-part2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"8bit Duels Devlog Part 2","name":"8bit Duels Devlog Part 2","description":"Hello readers! This is my progress for week 2 of coding my multiplayer game with Rust and Bevy. This post is a bit late, and should’ve been out yesterday, but I wasn\u0026rsquo;t able to make it in time. Anyways, here is my progress this week. As a reminder, this is only a side project, and I don\u0026rsquo;t work on it for extended periods of time, so progress is slow.\nIn this post, we will cover three things:","keywords":[],"articleBody":"Hello readers! This is my progress for week 2 of coding my multiplayer game with Rust and Bevy. This post is a bit late, and should’ve been out yesterday, but I wasn’t able to make it in time. Anyways, here is my progress this week. As a reminder, this is only a side project, and I don’t work on it for extended periods of time, so progress is slow.\nIn this post, we will cover three things:\nAsset loading: how I load the sprites for my game and access them throughout the code. Spawning troops: how I send the packets required to place troops on the board, which needs to be slightly different for each client. Game art progress: my two new sprites for the game. In this post, I will also show an image of how the game looks at the moment so you can give feedback in the comments, and maybe even come up with a name for the game (it still doesn’t have one). Without further ado, let’s get into it!\nAsset loading I have decided that all my character sprites will be 8x pixel art tiles. The best way to handle that is to put them all in a sprite sheet and use Bevy’s TextureAtlas struct and store it in a resource (Res) for our systems to use. This is done as such in the game/card.rs file:\n// game/card.rs pub(crate) struct CardSprites( pub(crate) Handle\u003cTextureAtlas\u003e, pub(crate) HashMap\u003cString, usize\u003e, ); fn load_card_sprites( mut commands: Commands, asset_server: Res\u003cAssetServer\u003e, mut texture_atlases: ResMut\u003cAssets\u003cTextureAtlas\u003e\u003e, ) { let sprite_sheet = asset_server.load(\"sprite_sheet.png\"); let atlas: TextureAtlas = TextureAtlas::from_grid(sprite_sheet, Vec2::splat(8.), 1, 1); let atlas_handle = texture_atlases.add(atlas); let mut card_sprite_map = HashMap::new(); card_sprite_map.insert(\"skeleton\".to_string(), 0); commands.insert_resource(CardSprites(atlas_handle, card_sprite_map)); } Here, we load the sprite_sheet.png file, which is in our assets folder. We tell Bevy to parse it as a grid of 8x8 tiles. This gives us a TextureAtlas, from which we store a Handle (sort of reference struct for Bevy) into our CardSprites resource. This resource also contains a map that allows us to get the index of a character’s texture with its name. This makes it very simple to add more characters later on. In other systems that need to access these sprites, we can just add Res to the function arguments. That is very helpful, as we will see later on.\nSpawning troops Now for the interesting part. We can finally start putting some stuff on the game board! To do this, we first have to go into the server side and code a way for it to send spawning packets to the clients.\n// net/packets.rs pub fn spawn_troop(card: \u0026Card, x_pos: i32, y_pos: i32, flip_board: bool) -\u003e Packet { let mut json: Value = serde_json::from_str( r#\" { \"packet-type\": \"spawn-card\" } \"#, ) .unwrap(); if let Value::Object(ref mut map) = json { let card_entity = CardEntity::new( card, if flip_board { 4 - x_pos } else { x_pos }, if flip_board { 8 - y_pos } else { y_pos }, ); map.insert( \"troop\".to_string(), serde_json::to_value(\u0026card_entity).unwrap(), ); } Packet { data: json } } } This is mostly some simple JSON object creation. However, notice there is an argument called flip_board. If it is set to true, this boolean makes it so we flip the x and y positions of the troop on the board (it’s a 5x9 board, that’s why there’s the 4 and the 8). This is necessary to insure that both clients see their perspective of the game. Here is what the handling of this packet looks like on the client side:\n// net/packet_handler.rs \"spawn-card\" =\u003e { if !matches!(packet[\"troop\"].clone(), Value::Null) { let result = serde_json::from_value::\u003cCardEntity\u003e(packet[\"troop\"].clone()); if result.is_ok() { let card_entity = result.unwrap(); let mut sprite = TextureAtlasSprite::new( card_sprites .1 .get(\u0026card_entity.card.get_name()) .unwrap() .clone(), ); sprite.custom_size = Some(Vec2::splat(tile_size.0 * 0.8)); commands .spawn_bundle(SpriteSheetBundle { sprite, texture_atlas: card_sprites.0.clone(), transform: Transform::from_xyz(0., 0., 500.), ..Default::default() }) .insert(card_entity); } } } Note: we need to add card_sprites: Res, to the function arguments so that we can access the sprites we loaded earlier.\nHere, we get the troop data from the packet if it exists. This returns a CardEntity (if you don’t know what this is, go check out the the week 1 devlog) that we can use to spawn the new troop. Here, it is placed at the (0, 0) coordinates. This is because we have another simple system that takes care of positioning the entities. This is what is looks like if we spawn a skeleton at (0, 0).\nGame art progress This week, I drew two very simple sprites that I’ll hopefully using by next week for character interactions. The blue tile is for movement and the red one is for attack.\nMeme of the week It’s that time again!\nOnce again, if you made it this far, thank you so much for reading. As for me, I’m out, and I hope to have some good progress to show for next week!\n","wordCount":"809","inLanguage":"en","datePublished":"2022-12-02T18:12:30-05:00","dateModified":"2022-12-02T18:12:30-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://thousandthstar.github.io/posts/8bd/8bd-part2/"},"publisher":{"@type":"Organization","name":"ThousandthStar's blog","logo":{"@type":"ImageObject","url":"https://thousandthstar.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://thousandthstar.github.io/ accesskey=h title="ThousandthStar's blog (Alt + H)">ThousandthStar's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://thousandthstar.github.io/posts/8bd/ title="8bit Duels"><span>8bit Duels</span></a></li><li><a href=https://thousandthstar.github.io/posts/news/ title=News><span>News</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>8bit Duels Devlog Part 2</h1><div class=post-meta><span title='2022-12-02 18:12:30 -0500 -0500'>December 2, 2022</span></div></header><div class=post-content><p>Hello readers! This is my progress for week 2 of coding my multiplayer game with Rust and Bevy. This post is a bit late, and should’ve been out yesterday, but I wasn&rsquo;t able to make it in time. Anyways, here is my progress this week. As a reminder, this is only a side project, and I don&rsquo;t work on it for extended periods of time, so progress is slow.</p><p>In this post, we will cover three things:</p><ul><li><strong>Asset loading</strong>: how I load the sprites for my game and access them throughout the code.</li><li><strong>Spawning troops</strong>: how I send the packets required to place troops on the board, which needs to be slightly different for each client.</li><li><strong>Game art progress</strong>: my two new sprites for the game.</li></ul><p>In this post, I will also show an image of how the game looks at the moment so you can give feedback in the comments, and maybe even come up with a name for the game (it still doesn&rsquo;t have one). Without further ado, let&rsquo;s get into it!</p><h3 id=asset-loading>Asset loading<a hidden class=anchor aria-hidden=true href=#asset-loading>#</a></h3><p>I have decided that all my character sprites will be 8x pixel art tiles. The best way to handle that is to put them all in a sprite sheet and use Bevy&rsquo;s <code>TextureAtlas</code> struct and store it in a resource (<code>Res</code>) for our systems to use. This is done as such in the <code>game/card.rs</code> file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// game/card.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span>(<span style=color:#66d9ef>crate</span>) <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CardSprites</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span>(<span style=color:#66d9ef>crate</span>) Handle<span style=color:#f92672>&lt;</span>TextureAtlas<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span>(<span style=color:#66d9ef>crate</span>) HashMap<span style=color:#f92672>&lt;</span>String, <span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>load_card_sprites</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mut</span> commands: <span style=color:#a6e22e>Commands</span>,
</span></span><span style=display:flex><span>    asset_server: <span style=color:#a6e22e>Res</span><span style=color:#f92672>&lt;</span>AssetServer<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mut</span> texture_atlases: <span style=color:#a6e22e>ResMut</span><span style=color:#f92672>&lt;</span>Assets<span style=color:#f92672>&lt;</span>TextureAtlas<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> sprite_sheet <span style=color:#f92672>=</span> asset_server.load(<span style=color:#e6db74>&#34;sprite_sheet.png&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> atlas: <span style=color:#a6e22e>TextureAtlas</span> <span style=color:#f92672>=</span> TextureAtlas::from_grid(sprite_sheet, Vec2::splat(<span style=color:#ae81ff>8.</span>), <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> atlas_handle <span style=color:#f92672>=</span> texture_atlases.add(atlas);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> card_sprite_map <span style=color:#f92672>=</span> HashMap::new();
</span></span><span style=display:flex><span>    card_sprite_map.insert(<span style=color:#e6db74>&#34;skeleton&#34;</span>.to_string(), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    commands.insert_resource(CardSprites(atlas_handle, card_sprite_map));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here, we load the sprite_sheet.png file, which is in our assets folder. We tell Bevy to parse it as a grid of 8x8 tiles. This gives us a <code>TextureAtlas</code>, from which we store a <code>Handle</code> (sort of reference struct for Bevy) into our <code>CardSprites</code> resource. This resource also contains a map that allows us to get the index of a character&rsquo;s texture with its name. This makes it very simple to add more characters later on. In other systems that need to access these sprites, we can just add <code>Res&lt;CardSprites></code> to the function arguments. That is very helpful, as we will see later on.</p><h3 id=spawning-troops>Spawning troops<a hidden class=anchor aria-hidden=true href=#spawning-troops>#</a></h3><p>Now for the interesting part. We can finally start putting some stuff on the game board! To do this, we first have to go into the server side and code a way for it to send spawning packets to the clients.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// net/packets.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>spawn_troop</span>(card: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Card</span>, x_pos: <span style=color:#66d9ef>i32</span>, y_pos: <span style=color:#66d9ef>i32</span>, flip_board: <span style=color:#66d9ef>bool</span>) -&gt; <span style=color:#a6e22e>Packet</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> json: <span style=color:#a6e22e>Value</span> <span style=color:#f92672>=</span> serde_json::from_str(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>r</span><span style=color:#e6db74>#&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                &#34;packet-type&#34;: &#34;spawn-card&#34;        
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;#</span>,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        .unwrap();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Value::Object(<span style=color:#66d9ef>ref</span> <span style=color:#66d9ef>mut</span> map) <span style=color:#f92672>=</span> json {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> card_entity <span style=color:#f92672>=</span> CardEntity::new(
</span></span><span style=display:flex><span>                card,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> flip_board { <span style=color:#ae81ff>4</span> <span style=color:#f92672>-</span> x_pos } <span style=color:#66d9ef>else</span> { x_pos },
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> flip_board { <span style=color:#ae81ff>8</span> <span style=color:#f92672>-</span> y_pos } <span style=color:#66d9ef>else</span> { y_pos },
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>            map.insert(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;troop&#34;</span>.to_string(),
</span></span><span style=display:flex><span>                serde_json::to_value(<span style=color:#f92672>&amp;</span>card_entity).unwrap(),
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Packet { data: <span style=color:#a6e22e>json</span> }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is mostly some simple JSON object creation. However, notice there is an argument called <code>flip_board</code>. If it is set to true, this boolean makes it so we flip the x and y positions of the troop on the board (it&rsquo;s a 5x9 board, that&rsquo;s why there&rsquo;s the 4 and the 8). This is necessary to insure that both clients see their perspective of the game. Here is what the handling of this packet looks like on the client side:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// net/packet_handler.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;spawn-card&#34;</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>matches!(packet[<span style=color:#e6db74>&#34;troop&#34;</span>].clone(), Value::Null) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            serde_json::from_value::<span style=color:#f92672>&lt;</span>CardEntity<span style=color:#f92672>&gt;</span>(packet[<span style=color:#e6db74>&#34;troop&#34;</span>].clone());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> result.is_ok() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> card_entity <span style=color:#f92672>=</span> result.unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sprite <span style=color:#f92672>=</span> TextureAtlasSprite::new(
</span></span><span style=display:flex><span>                card_sprites
</span></span><span style=display:flex><span>                    .<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                    .get(<span style=color:#f92672>&amp;</span>card_entity.card.get_name())
</span></span><span style=display:flex><span>                    .unwrap()
</span></span><span style=display:flex><span>                    .clone(),
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>            sprite.custom_size <span style=color:#f92672>=</span> Some(Vec2::splat(tile_size.<span style=color:#ae81ff>0</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.8</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            commands
</span></span><span style=display:flex><span>                .spawn_bundle(SpriteSheetBundle {
</span></span><span style=display:flex><span>                    sprite,
</span></span><span style=display:flex><span>                    texture_atlas: <span style=color:#a6e22e>card_sprites</span>.<span style=color:#ae81ff>0.</span>clone(),
</span></span><span style=display:flex><span>                    transform: <span style=color:#a6e22e>Transform</span>::from_xyz(<span style=color:#ae81ff>0.</span>, <span style=color:#ae81ff>0.</span>, <span style=color:#ae81ff>500.</span>),
</span></span><span style=display:flex><span>                    <span style=color:#f92672>..</span>Default::default()
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                .insert(card_entity);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Note:</strong> we need to add <code>card_sprites: Res&lt;CardSprites>,</code> to the function arguments so that we can access the sprites we loaded earlier.</p><p>Here, we get the troop data from the packet if it exists. This returns a <code>CardEntity</code> (if you don&rsquo;t know what this is, go check out the the week 1 devlog) that we can use to spawn the new troop. Here, it is placed at the (0, 0) coordinates. This is because we have another simple system that takes care of positioning the entities. This is what is looks like if we spawn a skeleton at (0, 0).</p><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wjswoazqscm5fyoz3e1o.png alt="sneak peak"></p><h3 id=game-art-progress>Game art progress<a hidden class=anchor aria-hidden=true href=#game-art-progress>#</a></h3><p>This week, I drew two very simple sprites that I&rsquo;ll hopefully using by next week for character interactions. The blue tile is for movement and the red one is for attack.</p><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vwmouyeeymp4b9pa513p.png alt=movement></p><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/lpjsr7yen2kn4ifz78vb.png alt=attack></p><h3 id=meme-of-the-week>Meme of the week<a hidden class=anchor aria-hidden=true href=#meme-of-the-week>#</a></h3><p>It&rsquo;s that time again!</p><p><img loading=lazy src=https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ejb76yq97w0d2prnapq4.jpg alt="java devs be like"></p><p>Once again, if you made it this far, thank you so much for reading. As for me, I&rsquo;m out, and I hope to have some good progress to show for next week!</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://thousandthstar.github.io/>ThousandthStar's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
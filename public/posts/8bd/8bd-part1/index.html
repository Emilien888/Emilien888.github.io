<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>8bit Duels Devlog Part 1 | ThousandthStar&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="Hello readers! Welcome to the week 1 devlog of my multiplayer game using Rust and the Bevy game engine. In this post, I will talk about my progress for the first week. This isn&rsquo;t the beginning of the project, but rather my first devlog. Without further ado, let&rsquo;s get into it!
Please note that you are more than welcome to comment on my code. Hints on how to make it more efficient, performant, etc.">
<meta name="author" content="">
<link rel="canonical" href="https://thousandthstar.github.io/posts/8bd/8bd-part1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css" integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://thousandthstar.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://thousandthstar.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://thousandthstar.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://thousandthstar.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://thousandthstar.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZP55MZZT7E"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-ZP55MZZT7E', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="8bit Duels Devlog Part 1" />
<meta property="og:description" content="Hello readers! Welcome to the week 1 devlog of my multiplayer game using Rust and the Bevy game engine. In this post, I will talk about my progress for the first week. This isn&rsquo;t the beginning of the project, but rather my first devlog. Without further ado, let&rsquo;s get into it!
Please note that you are more than welcome to comment on my code. Hints on how to make it more efficient, performant, etc." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://thousandthstar.github.io/posts/8bd/8bd-part1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-02T18:07:54-05:00" />
<meta property="article:modified_time" content="2022-12-02T18:07:54-05:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="8bit Duels Devlog Part 1"/>
<meta name="twitter:description" content="Hello readers! Welcome to the week 1 devlog of my multiplayer game using Rust and the Bevy game engine. In this post, I will talk about my progress for the first week. This isn&rsquo;t the beginning of the project, but rather my first devlog. Without further ado, let&rsquo;s get into it!
Please note that you are more than welcome to comment on my code. Hints on how to make it more efficient, performant, etc."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://thousandthstar.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "8bit Duels Devlog Part 1",
      "item": "https://thousandthstar.github.io/posts/8bd/8bd-part1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "8bit Duels Devlog Part 1",
  "name": "8bit Duels Devlog Part 1",
  "description": "Hello readers! Welcome to the week 1 devlog of my multiplayer game using Rust and the Bevy game engine. In this post, I will talk about my progress for the first week. This isn\u0026rsquo;t the beginning of the project, but rather my first devlog. Without further ado, let\u0026rsquo;s get into it!\nPlease note that you are more than welcome to comment on my code. Hints on how to make it more efficient, performant, etc.",
  "keywords": [
    
  ],
  "articleBody": "Hello readers! Welcome to the week 1 devlog of my multiplayer game using Rust and the Bevy game engine. In this post, I will talk about my progress for the first week. This isn’t the beginning of the project, but rather my first devlog. Without further ado, let’s get into it!\nPlease note that you are more than welcome to comment on my code. Hints on how to make it more efficient, performant, etc. are greatly appreciated.\nPacket handling and bug fixes I have just started the networking between the client and the server, and I already have had to fix two small but impactful and hard to find bugs (one was hiding in plain sight but I was too stupid to see it). But first, we have to take a look at how the networking in managed on both the client and server side. They both make use of threads to read and write to each other via TCP. They also use the std::sync::Mutex class wrapped in a std::sync::Arc to safely manage mutable references to the packet queues (more on them later).\nClient-side Related files: client/src/net/mod.rs client/src/net/input.rs client/src/net/out.rs client/src/net/packet_handler.rs Because of how the Bevy engine works, to get our packets to be read by the game, we need to pass them as resources to our App (Bevy uses the ECS architectural pattern). These resources can then be used by the systems that run on every time the game updates. These resources typically are tuple structs, because Bevy needs every different resource to be a different struct. We use a VecDeque object to make a queue for the packets, because it allows us to push data to the end of the queue, and then pop the front of it. Hence, we declare the queues as\n// mod.rs pub(crate) struct QueueIn(pub(crate) Arc\u003cMutex\u003cVecDeque\u003cString\u003e\u003e\u003e); pub(crate) struct QueueOut(pub(crate) Arc\u003cMutex\u003cVecDeque\u003cString\u003e\u003e\u003e); These create a way for our handle_packets to process and write packets.\n// packet_handler.rs fn handle_packets( mut queue_in: ResMut\u003cQueueIn\u003e, mut queue_out: ResMut\u003cQueueOut\u003e, mut commands: Commands, mut state: ResMut\u003cState\u003cGameState\u003e\u003e, ) { let mut guard = queue_in.0.lock().unwrap(); if !guard.is_empty() { let packet_to_read = guard.pop_front().unwrap(); let packet: Value = serde_json::from_str::\u003cValue\u003e(packet_to_read.as_str()).unwrap_or(Value::Null); if matches!(packet, Value::Object(_)) { if let Value::String(string) = packet[\"packet-type\"].clone() { match string.as_str() { \"server-start-game\" =\u003e { state.set(GameState::Playing); } \"none\" =\u003e { println!(\"bad packet from the server!\") } \u0026_ =\u003e {} } } } } drop(guard); } Here, we get the first packet (which is a String read from the TcpStream) in the queue and deserialize it using the serde_json crate. This parses it into a Value object, which represents JSON data. We then get the \"packet-type\" field from the JSON object, and if it exists, we use a simple match statement to handle the packet. You can also see that in the declaration of the function (functions represent systems in Bevy) that we tell Bevy to get the QueueIn and QueueOut resources, which is where the packets are located. We also need to drop() the MutexGuard (which gives us control over the queue) at the end of the function to let the rest of the code access it.\nTo read the packets from the server and to send the packets to it, we have too very basic threads that are spawned in input.rs and out.rs:\n//input.rs pub(crate) fn spawn_input_thread( queue_in_ref: Arc\u003cMutex\u003cVecDeque\u003cString\u003e\u003e\u003e, mut reader: BufReader\u003cTcpStream\u003e, ) { thread::spawn(move || { let mut buffer: [u8; 1024] = [0; 1024]; let mut received_data: usize; loop { received_data = reader.read(\u0026mut buffer).unwrap_or(0); if received_data \u003e 0 { if let Ok(string) = std::str::from_utf8_mut(\u0026mut buffer) { let mut guard = queue_in_ref.lock().unwrap(); guard.push_back(string.replace(\"\\0\", \"\").to_string()); drop(guard); buffer = [0; 1024]; } else { println!(\"Got an invalid UTF-8 packet!\") } } else { break; } } }); } We are using a 1024 character buffer, which should be more than enough for the packets we will receive. One thing to note, and which caused a lot of headaches, is that we need to remove every \\0 (whitespace) character. This happens because the buffer is always larger than the packet, which causes it to add unnecessary characters to the end of the String. This causes serde_json to fail to parse the packet.\n// out.rs pub(crate) fn spawn_output_thread(queue_out_ref: Arc\u003cMutex\u003cVecDeque\u003cString\u003e\u003e\u003e, mut stream: TcpStream){ thread::spawn(move || { loop{ let mut guard = queue_out_ref.lock().unwrap(); if guard.is_empty() {drop(guard); continue;} if stream.write(guard.pop_front().unwrap().as_bytes()).is_err(){ panic!(\"Error Writing to the server!\"); } drop(guard); } }); } Server-side. On the server side, we use a similar technique with the packet queues. However, here, they are managed by a Game struct which owns and operates on them (a Game represents a duel between two players). There isn’t much to see here, since it’s more of a simplified version of the client side, and we don’t use Bevy for the server.\nCommon protocol I haven’t started coding the gameplay yet, but I’ve established a way to communicate the Card (or Troop, haven’t decided on the name) data over the network. On both the client and the server, we have a game module, which contains the file card.rs. In this file, we define the structs that represent our Card data:\n// card.rs #[derive(Serialize, Deserialize, Clone, Debug)] pub struct Card { name: String, type_: CardType, hp: f32, attack: f32, cost: i32, abilities: Vec\u003cCardAbility\u003e, } #[derive(Serialize, Deserialize, Clone, Debug)] enum CardType { TROOP, SPELL, BUILDING, } #[derive(Serialize, Deserialize, Clone, Debug)] pub struct CardEntity{ card: Card, current_hp: i32, } #[derive(Serialize, Deserialize, Clone, Debug)] enum CardAbility { ProduceGold(i32), } As you can see, we have two Card structs and two enums. The Card struct defines the troops’ stats, including their abilities, which are defined in the CardAbility enum (more abilities will be added later). This will be useful when we need to code the game logic and check a troop’s properties. The CardType struct does not yet serve a specific purpose, but I still included it. Finally, the CardEntity struct represents a troop that is on the game board. It needs an additional hp (health points) property.\nThat concludes the brief coding progress progress made during this week.\nGame art progress I’ve finally decided on my color palette, and made this simple 8x skeleton pixel art, which I hope will be in the game at some point. I’m truly a beginner when it comes to art, however.\nMeme of the week It’s time for the meme of the week: Conclusion If you made it this far, thank you very much for reading. This has been the week #1 of my multiplayer game devlog. I hope to continue this series and post updates every week.\n",
  "wordCount" : "1077",
  "inLanguage": "en",
  "datePublished": "2022-12-02T18:07:54-05:00",
  "dateModified": "2022-12-02T18:07:54-05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://thousandthstar.github.io/posts/8bd/8bd-part1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ThousandthStar's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://thousandthstar.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://thousandthstar.github.io/" accesskey="h" title="ThousandthStar&#39;s blog (Alt + H)">ThousandthStar&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      8bit Duels Devlog Part 1
    </h1>
    <div class="post-meta"><span title='2022-12-02 18:07:54 -0500 EST'>December 2, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>Hello readers! Welcome to the week 1 devlog of my multiplayer game using Rust and the Bevy game engine. In this post, I will talk about my progress for the first week. This isn&rsquo;t the beginning of the project, but rather my first devlog. Without further ado, let&rsquo;s get into it!</p>
<p>Please note that you are more than welcome to comment on my code. Hints on how to make it more efficient, performant, etc. are greatly appreciated.</p>
<h2 id="packet-handling-and-bug-fixes">Packet handling and bug fixes<a hidden class="anchor" aria-hidden="true" href="#packet-handling-and-bug-fixes">#</a></h2>
<p>I have just started the networking between the client and the server, and I already have had to fix two small but impactful  and hard to find bugs (one was hiding in plain sight but I was too stupid to see it). But first, we have to take a look at how the networking in managed on both the client and server side. They both make use of threads to read and write to each other via TCP. They also use the <code>std::sync::Mutex</code> class wrapped in a <code>std::sync::Arc</code> to safely manage mutable references to the packet queues (more on them later).</p>
<h4 id="client-side">Client-side<a hidden class="anchor" aria-hidden="true" href="#client-side">#</a></h4>
<h6 id="related-files">Related files:<a hidden class="anchor" aria-hidden="true" href="#related-files">#</a></h6>
<ul>
<li><strong>client/src/net/mod.rs</strong></li>
<li><strong>client/src/net/input.rs</strong></li>
<li><strong>client/src/net/out.rs</strong></li>
<li><strong>client/src/net/packet_handler.rs</strong></li>
</ul>
<p>Because of how the Bevy engine works, to get our packets to be read by the game, we need to pass them as resources to our App (Bevy uses the <a href="https://en.wikipedia.org/wiki/Entity_component_system">ECS</a> architectural pattern). These resources can then be used by the systems that run on every time the game updates. These resources typically are tuple structs, because Bevy needs every different resource to be a different struct. We use a <code>VecDeque</code> object to make a queue for the packets, because it allows us to push data to the end of the queue, and then pop the front of it. Hence, we declare the queues as</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// mod.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">QueueIn</span>(<span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) Arc<span style="color:#f92672">&lt;</span>Mutex<span style="color:#f92672">&lt;</span>VecDeque<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;&gt;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">QueueOut</span>(<span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) Arc<span style="color:#f92672">&lt;</span>Mutex<span style="color:#f92672">&lt;</span>VecDeque<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;&gt;</span>);
</span></span></code></pre></div><p>These create a way for our <code>handle_packets</code> to process and write packets.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// packet_handler.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">handle_packets</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mut</span> queue_in: <span style="color:#a6e22e">ResMut</span><span style="color:#f92672">&lt;</span>QueueIn<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mut</span> queue_out: <span style="color:#a6e22e">ResMut</span><span style="color:#f92672">&lt;</span>QueueOut<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mut</span> commands: <span style="color:#a6e22e">Commands</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mut</span> state: <span style="color:#a6e22e">ResMut</span><span style="color:#f92672">&lt;</span>State<span style="color:#f92672">&lt;</span>GameState<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> guard <span style="color:#f92672">=</span> queue_in.<span style="color:#ae81ff">0.</span>lock().unwrap();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>guard.is_empty() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> packet_to_read <span style="color:#f92672">=</span> guard.pop_front().unwrap();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> packet: <span style="color:#a6e22e">Value</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>            serde_json::from_str::<span style="color:#f92672">&lt;</span>Value<span style="color:#f92672">&gt;</span>(packet_to_read.as_str()).unwrap_or(Value::Null);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> matches!(packet, Value::Object(_)) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Value::String(string) <span style="color:#f92672">=</span> packet[<span style="color:#e6db74">&#34;packet-type&#34;</span>].clone() {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">match</span> string.as_str() {
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;server-start-game&#34;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        state.set(GameState::Playing);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;none&#34;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        println!(<span style="color:#e6db74">&#34;bad packet from the server!&#34;</span>)
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">&amp;</span>_ <span style="color:#f92672">=&gt;</span> {}
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    drop(guard);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here, we get the first packet (which is a <code>String</code> read from the TcpStream) in the queue and deserialize it using the <code>serde_json</code> crate. This parses it into a <code>Value</code> object, which represents JSON data. We then get the <code>&quot;packet-type&quot;</code> field from the JSON object, and if it exists, we use a simple <code>match</code> statement to handle the packet. You can also see that in the declaration of the function (functions represent systems in Bevy) that we tell Bevy to get the <code>QueueIn</code> and <code>QueueOut</code> resources, which is where the packets are located. We also need to <code>drop()</code> the <code>MutexGuard</code> (which gives us control over the queue) at the end of the function to let the rest of the code access it.</p>
<p>To read the packets from the server and to send the packets to it, we have too very basic threads that are spawned in <code>input.rs</code> and <code>out.rs</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">//input.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">spawn_input_thread</span>(
</span></span><span style="display:flex;"><span>    queue_in_ref: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>Mutex<span style="color:#f92672">&lt;</span>VecDeque<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mut</span> reader: <span style="color:#a6e22e">BufReader</span><span style="color:#f92672">&lt;</span>TcpStream<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buffer: [<span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">1024</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>; <span style="color:#ae81ff">1024</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> received_data: <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>            received_data <span style="color:#f92672">=</span> reader.read(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buffer).unwrap_or(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> received_data <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Ok(string) <span style="color:#f92672">=</span> std::<span style="color:#66d9ef">str</span>::from_utf8_mut(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buffer) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> guard <span style="color:#f92672">=</span> queue_in_ref.lock().unwrap();
</span></span><span style="display:flex;"><span>                    guard.push_back(string.replace(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\0</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>).to_string());
</span></span><span style="display:flex;"><span>                    drop(guard);
</span></span><span style="display:flex;"><span>                    buffer <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>; <span style="color:#ae81ff">1024</span>];
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    println!(<span style="color:#e6db74">&#34;Got an invalid UTF-8 packet!&#34;</span>)
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We are using a 1024 character buffer, which should be more than enough for the packets we will receive. One thing to note, and which caused a lot of headaches, is that we need to remove every <code>\0</code> (whitespace) character. This happens because the buffer is always larger than the packet, which causes it to add unnecessary characters to the end of the <code>String</code>. This causes <code>serde_json</code> to fail to parse the packet.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// out.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">spawn_output_thread</span>(queue_out_ref: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>Mutex<span style="color:#f92672">&lt;</span>VecDeque<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;&gt;</span>, <span style="color:#66d9ef">mut</span> stream: <span style="color:#a6e22e">TcpStream</span>){
</span></span><span style="display:flex;"><span>    thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">loop</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> guard <span style="color:#f92672">=</span> queue_out_ref.lock().unwrap();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> guard.is_empty() {drop(guard); <span style="color:#66d9ef">continue</span>;}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> stream.write(guard.pop_front().unwrap().as_bytes()).is_err(){
</span></span><span style="display:flex;"><span>                panic!(<span style="color:#e6db74">&#34;Error Writing to the server!&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            drop(guard);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="server-side">Server-side.<a hidden class="anchor" aria-hidden="true" href="#server-side">#</a></h4>
<p>On the server side, we use a similar technique with the packet queues. However, here, they are managed by a <code>Game</code> struct which owns and operates on them (a <code>Game</code> represents a duel between two players). There isn&rsquo;t much to see here, since it&rsquo;s more of a simplified version of the client side, and we don&rsquo;t use Bevy for the server.</p>
<h4 id="common-protocol">Common protocol<a hidden class="anchor" aria-hidden="true" href="#common-protocol">#</a></h4>
<p>I haven&rsquo;t started coding the gameplay yet, but I&rsquo;ve established a way to communicate the <code>Card</code> (or Troop, haven&rsquo;t decided on the name) data over the network. On both the client and the server, we have a <code>game</code> module, which contains the file <code>card.rs</code>. In this file, we define the structs that represent our <code>Card</code> data:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// card.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#[derive(Serialize, Deserialize, Clone, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Card</span> {
</span></span><span style="display:flex;"><span>    name: String,
</span></span><span style="display:flex;"><span>    type_: <span style="color:#a6e22e">CardType</span>,
</span></span><span style="display:flex;"><span>    hp: <span style="color:#66d9ef">f32</span>,
</span></span><span style="display:flex;"><span>    attack: <span style="color:#66d9ef">f32</span>,
</span></span><span style="display:flex;"><span>    cost: <span style="color:#66d9ef">i32</span>,
</span></span><span style="display:flex;"><span>    abilities: Vec<span style="color:#f92672">&lt;</span>CardAbility<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[derive(Serialize, Deserialize, Clone, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">CardType</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">TROOP</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">SPELL</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">BUILDING</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[derive(Serialize, Deserialize, Clone, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">CardEntity</span>{
</span></span><span style="display:flex;"><span>    card: <span style="color:#a6e22e">Card</span>,
</span></span><span style="display:flex;"><span>    current_hp: <span style="color:#66d9ef">i32</span>,
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[derive(Serialize, Deserialize, Clone, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">CardAbility</span> {
</span></span><span style="display:flex;"><span>    ProduceGold(<span style="color:#66d9ef">i32</span>),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see, we have two <code>Card</code> structs and two enums. The <code>Card</code> struct defines the troops&rsquo; stats, including their abilities, which are defined in the <code>CardAbility</code> enum (more abilities will be added later). This will be useful when we need to code the game logic and check a troop&rsquo;s properties. The <code>CardType</code> struct does not yet serve a specific purpose, but I still included it. Finally, the <code>CardEntity</code> struct represents a troop that is on the game board. It needs an additional hp (health points) property.</p>
<p>That concludes the brief coding progress progress made during this week.</p>
<h4 id="game-art-progress">Game art progress<a hidden class="anchor" aria-hidden="true" href="#game-art-progress">#</a></h4>
<p>I&rsquo;ve finally decided on my color palette, and made this simple 8x skeleton pixel art, which I hope will be in the game at some point. I&rsquo;m truly a beginner when it comes to art, however.</p>
<p><img loading="lazy" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/dlectqe8cjh7k3bopxer.png" alt="skelly"  />
</p>
<h4 id="meme-of-the-week">Meme of the week<a hidden class="anchor" aria-hidden="true" href="#meme-of-the-week">#</a></h4>
<p>It&rsquo;s time for the meme of the week:
<img loading="lazy" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qzaxb5orjql1hbh05p79.jpg" alt="meme"  />
</p>
<h4 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h4>
<p>If you made it this far, thank you very much for reading. This has been the week #1 of my multiplayer game devlog. I hope to continue this series and post updates every week.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://thousandthstar.github.io/">ThousandthStar&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
